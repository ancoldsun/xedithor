void GraphWidget::drawBackground(QPainter *painter, const QRectF &rect)
{

    Q_UNUSED(rect);

    //--


    int gridInterval = 10; //interval to draw grid lines at
    painter->setWorldMatrixEnabled(true);

    qreal left = int(rect.left()) - (int(rect.left()) % gridInterval );
    qreal top = int(rect.top()) - (int(rect.top()) % gridInterval );

    QVarLengthArray<QLineF, 100> linesX;
    for (qreal x = left; x < rect.right(); x += gridInterval )
    linesX.append(QLineF(x, rect.top(), x, rect.bottom()));

    QVarLengthArray<QLineF, 100> linesY;
    for (qreal y = top; y < rect.bottom(); y += gridInterval )
    linesY.append(QLineF(rect.left(), y, rect.right(), y));

    painter->drawLines(linesX.data(), linesX.size());
    painter->drawLines(linesY.data(), linesY.size());

    // draw background Shadow

    QRectF sceneRect = this->sceneRect();
    QRectF rightShadow(sceneRect.right(), sceneRect.top() + 5, 5, sceneRect.height());
    QRectF bottomShadow(sceneRect.left() + 5, sceneRect.bottom(), sceneRect.width(), 5);
    if (rightShadow.intersects(rect) || rightShadow.contains(rect))
        painter->fillRect(rightShadow, Qt::darkGray);
    if (bottomShadow.intersects(rect) || bottomShadow.contains(rect))
        painter->fillRect(bottomShadow, Qt::darkGray);

    // Fill
    QLinearGradient gradient(sceneRect.topLeft(), sceneRect.bottomRight());
    gradient.setColorAt(0, Qt::white);
    gradient.setColorAt(1, Qt::lightGray);
    painter->fillRect(rect.intersect(sceneRect), gradient);
    painter->setBrush(Qt::NoBrush);
    painter->drawRect(sceneRect);



#if !defined(Q_OS_SYMBIAN) && !defined(Q_WS_MAEMO_5)
    // Text
    QRectF textRect(sceneRect.left() + 4, sceneRect.top() + 4,
                    sceneRect.width() - 4, sceneRect.height() - 4);
    QString message(tr("Click and drag the nodes around, and zoom with the mouse "
                       "wheel or the '+' and '-' keys"));

    QFont font = painter->font();
    font.setBold(true);
    font.setPointSize(14);
    painter->setFont(font);
    painter->setPen(Qt::lightGray);
    painter->drawText(textRect.translated(2, 2), message);
    painter->setPen(Qt::black);
    painter->drawText(textRect, message);
#endif
    //
    //QRectF textRect(sceneRect.left() + 4, sceneRect.top() + 4,
    //                sceneRect.width() - 4, sceneRect.height() - 4);
    QString message(tr("Click and drag the nodes around, and zoom with the mouse "
                       "wheel or the '+' and '-' keys"));
    QFont font = painter->font();
    font.setBold(true);
    font.setPointSize(14);
    painter->setFont(font);
    painter->setPen(Qt::lightGray);
    //painter->drawText(textRect.translated(2, 2), message);
    painter->setPen(Qt::black);
    painter->drawText(-300,-300, QString(tr("aaa")));

}

=====================

    //Populate the scene
    /*
    for(int x = 0; x < WidthRectView; x = x + 25) {
        for(int y = 0; y < HeightRectView; y = y + 25) {

            if(x % 100 == 0 && y % 100 == 0) {
                Scene->addRect(x, y, 2, 2);

                QString pointString;
                QTextStream stream(&pointString);
                stream << "(" << x << "," << y << ")";
                QGraphicsTextItem* item = Scene->addText(pointString);
                item->setPos(x, y);
            } else {
                Scene->addRect(x, y, 1, 1);
            }
        }
    }
    */

        qDebug(QString::number( index.column()).toStdString().c_str());

///////////////////////////////




    for(int i=0;i<_model->rowCount();i++) // loop n frames
    {
        RowData* rd = _model->getDatainRow(i);
        int id_ =rd->getData(1).toInt();
        int px_   =rd->getData(2).toInt();
        int py_   =rd->getData(3).toInt();
        for(int j=0;j<_modelframe->rowCount();j++)
        {
            //std::cout<<" bb "<<std::endl;
            RowData* rd2 = _modelframe->getDatainRow(j);
            int id_frame = rd2->getData(1).toInt();
            if(id_ == id_frame)
            {
                std::cout<<" FRAME:  "<<id_frame<<std::endl;
                ModuleTableModel* m = _modelframe->getModel(j);

                for(int k=0;k<m->rowCount();k++)
                {

                    //std::cout<<" zz "<<std::endl;
                    RowData* rd3 = m->getDatainRow(k);
                    int id_mod   = rd3->getData(1).toInt();
                    int fpx_   =rd3->getData(2).toInt();
                    int fpy_   =rd3->getData(3).toInt();
                    for(int l=0;l<_modelmod->rowCount();l++)
                    {
                        RowData* rd4 = _modelmod->getDatainRow(l);
                        if(id_mod == rd4->getData(1).toInt())
                        {
                            std::cout<<" Module:  "<<id_mod<<std::endl;
                            //std::cout<<" AA "<<std::endl;
                            int mpx_   =rd4->getData(2).toInt();
                            int mpy_   =rd4->getData(3).toInt();
                            int mw_    =rd4->getData(4).toInt();
                            int mh_    =rd4->getData(5).toInt();

                            QPixmap pieceImage =pixmapGraphicsItem->pixmap().copy(mpx_, mpy_, mw_, mh_);

                            int posx_ = px_ + fpx_;
                            int posy_ = py_ + fpy_;
                            QGraphicsPixmapItem* itemPixMap= new QGraphicsPixmapItem(pieceImage);
                            itemPixMap->setPos(posx_ + WidthRectView / 2 ,posy_ +  HeightRectView / 2 );
                            //itemPixMap->setFlag(QGraphicsItem::ItemIsSelectable, true);
                            //itemPixMap->setFlag(QGraphicsItem::ItemSendsGeometryChanges, true);
                            itemPixMap->setAcceptHoverEvents ( true);
                            //itemPixMap->setFlag( QGraphicsItem::ItemIsMovable, true );

                            QVariant varI;
                            int id_ =0;
                            varI.setValue(id_);
                            itemPixMap->setData(0,varI);
                            this->scene()->addItem(itemPixMap);

                            /*
                            QGraphicsItemAnimation *animation = new QGraphicsItemAnimation;
                            animation->setItem(itemPixMap);
                            animation->setTimeLine(timeline);
                            animation->setRotationAt (1, 360);
                            QObject::connect (timeline, SIGNAL(finished()), animation, SLOT(deleteLater()));
                            */
                        }
                    }

                }
            }
        }

   }











